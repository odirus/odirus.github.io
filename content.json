{"pages":[],"posts":[{"title":"Hexo使用中遇到的问题以及解决办法","text":"安装过程中的问题 当更新博客内容后，Github pages 会失效的问题 解决方案：执行 hexo-deploy 命令后 Github Pages 自定义域名失效的问题","link":"/2020/01/04/Hexo%E4%BD%BF%E7%94%A8%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"},{"title":"Java多线程实战1","text":"本文开始，将会以各种多线程相关的题目为基础，逐一进行分析，先开始从一个简单的例子开始。 问题剖析题目：编号分别为 0 和 1 的线程，按照 ”偶数、奇数、偶数、奇数“ 的顺序输出结果，请严格确保输出顺序、线程能够正确退出。 方案如下，该方案有瑕疵，请谨慎阅读 1234567891011121314151617181920212223public class Solution { static class SolutionTask implements Runnable{ static int value = 0; @Override public void run() { while (value &lt;= 100){ synchronized (SolutionTask.class){ System.out.println(Thread.currentThread().getName() + \":\" + value++); SolutionTask.class.notify(); try { SolutionTask.class.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } } } } public static void main(String[] args) { new Thread(new SolutionTask(), \"偶数\").start(); new Thread(new SolutionTask(), \"奇数\").start(); }} 方案分析 该方案其实存在以下的一些问题 线程最后不会自动退出。最后一个线程执行 SolutionTask.class.notify() 后再执行 SolutionTask.class.wait()，因而线程一直在等待。 输出顺序不一定是 ”偶数、奇数“，有可能是 ”奇数、偶数“ 的情况，涉及到线程切换的问题。 解决方案123456789101112131415161718192021222324252627282930313233343536373839404142public class Solution { static class SolutionTask implements Runnable{ static int value = 0; int threadNo; SolutionTask(int threadNo) { this.threadNo = threadNo; } @Override public void run() { while (value &lt;= 100) { synchronized (SolutionTask.class){ // 判断线程对应关系，避免乱序 while (value % 2 != threadNo) { // 确保最后一个线程被唤醒后能够退出 if (value &gt; 100) { break; } try { SolutionTask.class.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } if (value &gt; 100) { break; } System.out.println(Thread.currentThread().getName() + \":\" + value++); SolutionTask.class.notify(); } } } } public static void main(String[] args) { new Thread(new SolutionTask(0), \"偶数\").start(); new Thread(new SolutionTask(1), \"奇数\").start(); }} 处理类似问题的时候，也一定要对边界情况进行思考，特别是开始、结束部分，避免出现不符合题意的输出结果，类似于数据中的归纳法证明。 还有另外一点需要注意，线程共享变量 value 没必要使用 volatile 变量，原因是当线程被唤醒后再次通过 sychronized 获取互斥锁，sychronized 已经可以保证变量的可见性了。","link":"/2020/02/19/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E6%88%981/"},{"title":"Kong插件开发-重写响应消息体","text":"本篇文章主要讲述如何通过 kong 插件重写响应给客户端的消息体内容，以下内容基于 kong v1.4.x 版本，官方文档。 按照官方文档，可以通过以下指令来重写返回给客户端的消息体，但只有在特定阶段才能重写 1234kong.response.exit(status[, body[, headers]])Phase:rewrite, access, admin_api, header_filter (only if body is nil) 假设我们的需求是当收到 Upstream 返回失败时（Http Status Code &gt;= 400 ）修改返回客户端的响应体，使用 kong pdk 中的接口都会提示执行错误，因为 header_filter 以及以后的阶段是不能直接修改的。 但我们可以通过执行 ngx 的一些指令来实现这个操作，该用法出现在 kong 官方插件 response-transformer 中，经过测试，可以满足该需求 1234567891011121314151617181920212223local kong = konglocal ngx = ngxlocal concat = table.concat# 因为会修改返回的响应体内容，所以要去掉此 headerkong.response.clear_header(&quot;Content-Length&quot;)# 修改返回给调用端的响应体内容local ctx = ngx.ctxlocal chunk, eof = ngx.arg[1], ngx.arg[2]ctx.rt_body_chunks = ctx.rt_body_chunks or {}ctx.rt_body_chunk_number = ctx.rt_body_chunk_number or 1if eof then local chunks = concat(ctx.rt_body_chunks) local body = responseBody ngx.arg[1] = body or chunkselse ctx.rt_body_chunks[ctx.rt_body_chunk_number] = chunk ctx.rt_body_chunk_number = ctx.rt_body_chunk_number + 1 ngx.arg[1] = nilend","link":"/2019/12/23/Kong%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91-%E9%87%8D%E5%86%99%E5%93%8D%E5%BA%94%E6%B6%88%E6%81%AF%E4%BD%93/"}],"tags":[{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"java","slug":"java","link":"/tags/java/"},{"name":"kong","slug":"kong","link":"/tags/kong/"}],"categories":[]}